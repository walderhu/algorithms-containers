  /*
  Метод load_factor в классе std::unordered_set используется для получения
  текущего коэффициента загрузки контейнера. Коэффициент загрузки — это
  отношение количества элементов в контейнере к количеству ведер (buckets),
  используемых для хранения этих элементов. Он позволяет оценить, насколько
  эффективно распределены элементы по ведрам и может помочь в управлении
  производительностью хэш-таблицы.

  я сначала создаю 100 пустых ведер, но они пустые
  считать их полноценно их ведрами можно только после того как там есть хотя бы
  1 элемент в случае сток сета использую size потому что он полностью
  семанимичен, в мультисете отдельный метод
  */
  /*
    template <class... Args>
    iterator emplace_hint(const_iterator position, Args &&...args);
  итератор это подсказка, мы можем игнорировать его полностью, но не стоит
  */








  /*
  void reserve(size_type n);
   unordered_set<string> mySet;
    mySet.reserve(5); // Резервируем место для как минимум 5 корзин

    mySet.insert("яблоко");
    mySet.insert("банан");
    mySet.insert("вишня");

    cout << "Количество корзин после резервирования: " << mySet.bucket_count() << endl;

  просто переопределить более корректную table_max для такущей структуры
  и переопределить ее
  */

  /*
  Метод rehash в классе std::unordered_set используется для изменения количества
  ведер (buckets) в контейнере. Он позволяет установить новое количество ведер,
  что может быть полезно для оптимизации производительности при добавлении
  элементов.
  void rehash(size_type n);
  в моем случае начальное значение этих ведер это table_max
  */


rehash и reserve — это методы, используемые в стандартных контейнерах C++, но они служат для разных целей и применяются в различных контекстах.
Основные различия
1. Назначение
rehash(size_type n): Этот метод используется в контейнерах, таких как std::unordered_map и std::unordered_set, для изменения количества бакетов (или корзин) в хэш-таблице. Он пересчитывает хэш-таблицу, чтобы распределить существующие элементы по новому количеству бакетов, что может помочь в оптимизации производительности при увеличении количества элементов.
reserve(size_type n): Этот метод используется в контейнерах, таких как std::vector, для предварительного резервирования памяти. Он не изменяет размер контейнера, а лишь устанавливает минимальную емкость, чтобы избежать повторных выделений памяти при добавлении новых элементов.
2. Влияние на размер и емкость
rehash: Изменяет количество бакетов в хэш-таблице и может изменить распределение элементов между ними. Это может повлиять на производительность операций поиска и вставки.
reserve: Увеличивает емкость контейнера (например, вектора), но не меняет его размер. Это позволяет избежать затрат на перераспределение памяти при добавлении новых элементов.
3. Инициализация элементов
rehash: Не инициализирует элементы заново; он просто перераспределяет существующие элементы по новым бакетам.
reserve: Тоже не инициализирует элементы, но гарантирует, что выделено достаточно памяти для будущих вставок.
4. Синтаксис
void rehash(size_type n);: Применяется для изменения количества бакетов.
void reserve(size_type n);: Применяется для резервирования памяти.
Когда использовать
Используйте rehash, когда вы ожидаете значительное увеличение числа элементов в хэш-контейнере и хотите оптимизировать производительность.
Используйте reserve, когда вы знаете, что будете добавлять много элементов в вектор или аналогичный контейнер, чтобы уменьшить количество перераспределений памяти.
Эти методы помогают управлять эффективностью работы с динамическими структурами данных, обеспечивая оптимизацию использования памяти и производительности.






































  /*
  Метод key_eq в классе std::unordered_set возвращает функцию, которая
  используется для сравнения ключей на равенство. Это позволяет пользователю
  проверить, равны ли два ключа, используя определенный предикат сравнения,
  который может быть задан при создании unordered_set.
  key_equal key_eq() const;
      auto cmpfn = mySet.key_eq();

  Проверяем равенство двух символов
    std::cout << "cmpfn('a', 'a') == " << std::boolalpha << cmpfn('a', 'a') <<
  std::endl; // true std::cout << "cmpfn('a', 'b') == " << std::boolalpha <<
  cmpfn('a', 'b') << std::endl; // false

  */
  /*
  Метод get_allocator в классе std::unordered_set возвращает объект
  распределителя (allocator), который используется для управления памятью в
  контейнере. Это позволяет пользователям получить доступ к распределителю,
  который был использован для выделения памяти для элементов в unordered_set.
  allocator_type get_allocator() const noexcept;
    std::unordered_set<int> mySet;

    // Получаем распределитель
    auto alloc = mySet.get_allocator();

    // Выводим адреса выделенной памяти
    int* p = alloc.allocate(1); // Выделяем память для одного элемента
    *p = 42; // Присваиваем значение

    std::cout << "Allocated memory for value: " << *p << std::endl;

    alloc.deallocate(p, 1); // Освобождаем память
  */
